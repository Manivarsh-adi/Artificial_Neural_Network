import numpy as np


class PerceptronModel(object):

    # initializing constructor with required parameters
    def __init__(self, eta=0.31, n_iter=20):
        self.eta = eta
        self.n_iter = n_iter

    # This is fit function takes input and target, trains on input data and updates initialized weights
    # based on error generated by weights.
    def fit(self, x, y):

        # Initializing weights includes weights and bias
        self.w = np.zeros(1 + x.shape[1])
        k = 1
        for _ in range(self.n_iter):
            flag = 0
            for xi, target in zip(x, y):
                # calling the predict method
                y_predict = [self.predict(xi)]
                # calculating error
                error = target - y_predict
                if error != 0:
                    flag = 1
                    # updating weights and bais
                    update = self.eta*target
                    self.w[1:] += update*xi
                    self.w[0] += update
            k += 1
            if flag == 0:
                break
        return self

    # This method calculates net input of weights and input data
    def net_input(self, x):
        y = np.dot(x, self.w[1:]+self.w[0])
        return y

    # predict the value using net input, it is decision classifier
    def predict(self, x):
        return np.where(self.net_input(x) >= 0.0, 1, -1)
